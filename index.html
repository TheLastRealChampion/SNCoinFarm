<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secret Neighbor Exploits</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-image: url('https://wallpaperaccess.com/full/9331537.jpg');
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
    }

    h1 {
      margin-top: 40px;
      text-shadow: 2px 2px 4px #000;
    }

    .container {
      width: 95%;
      max-width: 1200px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding-bottom: 40px;
    }

    .section {
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      padding: 20px;
      border-radius: 10px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }

    .section h2 {
      margin-top: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 10px;
    }

    input, button, select {
      margin: 8px 5px;
      padding: 10px;
      font-size: 16px;
      width: 90%;
      max-width: 400px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #45a049;
    }

    .output {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 5px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
      color: black;
      text-align: left;
      max-height: 300px;
      overflow-y: auto;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .player-id-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    ol {
      text-align: left;
      padding-left: 20px;
    }

    a {
      color: #4da6ff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-active {
      background-color: #4CAF50;
    }

    .status-inactive {
      background-color: #f44336;
    }

    .warning {
      color: #ffcc00;
      font-weight: bold;
      margin: 10px 0;
    }

    .api-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .purchase-all-btn {
      background-color: #ff9900;
      font-weight: bold;
    }
    
    .purchase-all-btn:hover {
      background-color: #e68a00;
    }
    
    .renew-btn {
      background-color: #2196F3;
    }
    
    .renew-btn:hover {
      background-color: #0b7dda;
    }
  </style>
</head>
<body>
  <h1>üéÆ Secret Neighbor Exploits</h1>

  <div class="container">
    <div class="section">
      <h2>üîê Session Ticket</h2>
      <input id="sessionTicketInput" placeholder="Paste your SessionTicket here" type="text">
      <button onclick="setSessionTicket()">Set Token</button>
      <div class="grid-2">
        <button class="renew-btn" onclick="renewSessionTicket()">Renew SessionTicket</button>
        <button onclick="clearSessionTicket()">Clear Token</button>
      </div>
      <div id="tokenStatus" class="output" style="display: none;">No token set</div>
    </div>

    <!-- NEW SECTION: Purchase All Skins and Emotes -->
    <div class="section">
      <h2>üõí Purchase All Skins & Emotes</h2>
      <p class="warning">This will attempt to purchase all available items that use FE, AC, or XP currency</p>
      <button class="purchase-all-btn" onclick="purchaseAllSkinsEmotes()">Attempt to Purchase All Skins and Emotes</button>
      <div class="output" id="purchaseAllOutput">Purchase logs will appear here...</div>
    </div>

    <div class="section">
      <h2>üõçÔ∏è Buy Skin/Emote</h2>
      <input id="itemId" placeholder="ItemId" type="text">
      <input id="price" placeholder="Price" type="number">
      <input id="currency" placeholder="VirtualCurrency" type="text">
      <button onclick="buySkinEmote()">Buy Skin/Emote</button>
      <div class="output" id="purchaseOutput">Purchase results will appear here...</div>
    </div>

    <div class="section">
      <h2>üéÅ Grant Coupons</h2>
      <button onclick="grantCoupons()">Grant Coupons</button>
      <div class="output" id="couponOutput">Coupon results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìä View Statistics</h2>
      <button onclick="viewStatistics()">View Statistics</button>
      <div class="output" id="statsOutput">Statistics will appear here...</div>
    </div>

    <div class="section">
      <h2>üßë‚Äçüíª Obtain Player ID With Username</h2>
      <input id="steamUsername" placeholder="Steam Username" type="text">
      <button onclick="getPlayFabId()">Obtain Player ID</button>
      <div class="output" id="playerIdOutput">Player ID will appear here...</div>
    </div>

    <div class="section">
      <h2>üí∞ Add Coin (Call it In-Game)</h2>
      <p class="warning">Warning: Do not use more than 30 coins per match!</p>
      <button onclick="AddCoin()">Add Coin</button>
      <div class="output" id="usefulDeedOutput">Coin results will appear here...</div>
    </div>

    <div class="section">
      <h2>ü§ñ Coin Farm Bot <span id="botStatus" class="status-indicator status-inactive"></span></h2>
      <div class="grid-2">
        <div>
          <label>Room Type:</label>
          <select id="roomType">
            <option value="QUICK_GAME">QUICK_GAME</option>
            <option value="CUSTOM_GAME">CUSTOM_GAME</option>
          </select>
        </div>
        <div>
          <label>Delay:</label>
          <select id="delaySelect">
            <option value="10">10 minutes</option>
            <option value="5">5 minutes</option>
            <option value="2">2 minutes</option>
          </select>
        </div>
      </div>
      
      <div class="player-id-inputs">
        <input id="playerId1" placeholder="Player ID 1" type="text">
        <input id="playerId2" placeholder="Player ID 2" type="text">
        <input id="playerId3" placeholder="Player ID 3" type="text">
        <input id="playerId4" placeholder="Player ID 4" type="text">
        <input id="playerId5" placeholder="Player ID 5" type="text">
        <input id="playerId6" placeholder="Player ID 6" type="text">
      </div>
      
      <button onclick="toggleCoinFarmBot()" id="botToggleButton">Start Coin Farm Bot</button>
      <div class="output" id="cloudOutput">Bot output will appear here...</div>
    </div>

    <div class="section">
      <h2>üß™ Level Editor <span id="levelEditorStatus" class="status-indicator status-inactive"></span></h2>
      <input type="text" id="classIdInput" placeholder="Class ID">
      <input type="number" id="receivedXPInput" placeholder="Received XP">
      <input type="number" id="xpInput" placeholder="XP">
      <input type="number" id="xpToNextLevelInput" placeholder="XP to Next Level">
      <input type="number" id="levelInput" placeholder="Level">
      <input type="number" id="perkSlotsInput" placeholder="Available Perk Slots (max 3)" max="3" min="0">
      <input type="number" id="playerLevelInput" placeholder="Player Level">
      <button onclick="toggleLevelEditor()" id="levelEditorToggleButton">Start Level Editor</button>
      <div class="output" id="levelProgressionOutput">Level progression results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîç PlayFab Info Lookup</h2>
      <input type="text" id="playfabId" placeholder="Enter PlayFab ID">
      <button onclick="getPlayFabInfo()">Get Info</button>
      <div class="output" id="playfabInfoOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìù Update Quest Progress</h2>
      <input type="text" id="questTextFieldId" placeholder="Quest Text Field ID">
      <input type="number" id="questProgressValue" placeholder="Progress Value">
      <button onclick="updateQuestProgress()">Update Quest</button>
      
      <div style="margin-top: 15px; text-align: left;">
        <h3>Available Quests:</h3>
        <div style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
          <ul style="columns: 2; margin: 0; padding-left: 20px;">
            <li>QUENTIN_USE_DASH</li>
            <li>WIN_AS_BAGGER</li>
            <li>WIN_AS_BRAVE</li>
            <li>WIN_AS_DETECTIVE</li>
            <li>WIN_AS_ENGINEER</li>
            <li>WIN_AS_LEADER</li>
            <li>WIN_AS_SCOUT</li>
            <li>WIN_AS_SCARY</li>
            <li>WIN_AS_CLOWN</li>
            <li>WIN_AS_BUTCHER</li>
            <li>WIN_FIRST_TO_ESCAPE</li>
            <li>WIN_WITH_HALF_LOCKS_INTACT</li>
            <li>OPEN_LOCKS</li>
            <li>OPEN_LOCKS_IN_ONE_MATCH</li>
            <li>SEearch_DRAWERS</li>
            <li>FIND_KEYS_VIA_PHOTO</li>
            <li>USE_KEYCARDS</li>
            <li>CATCH_KIDS</li>
            <li>HOOK_KIDS</li>
            <li>CATCH_FROM_ITEM_FORM</li>
            <li>CATCH_INSIDE_SMOKE</li>
            <li>CATCH_IN_BEARTRAP</li>
            <li>BLIND_NEIGHBOR_WITH_LEADER</li>
            <li>BUFF_AS_LEADER</li>
            <li>CRAFT_RIFLE</li>
            <li>SHOOT_THE_SHERIFF</li>
            <li>SLINGSHOT_HIT_NEIGHBOR</li>
            <li>SAVE_KID_FROM_GRAB</li>
            <li>BRAVE_ESCAPE_FROM_NEIGHBOR_HANDS</li>
            <li>BAGGER_CARRIER</li>
            <li>GLUE_THE_NEIGHBOR</li>
            <li>CONSUME_CHOCOLATE</li>
            <li>CONSUME_MILK</li>
            <li>CATCH_FROZEN_KIDS</li>
            <li>CATCH_AFTER_PORTAL</li>
            <li>KNOCK_ITEMS_OUT_OF_HANDS</li>
            <li>CATCH_SCARED_KIDS</li>
            <li>CRAFT_NIGHT_VISION</li>
            <li>FIND_WITH_METAL_DETECTOR</li>
            <li>RANDOM_KID</li>
            <li>RANDOM_NEIGHBOR</li>
            <li>WIN_AS_GHOST</li>
            <li>WIN_AS_GUEST</li>
            <li>WIN_AS_QUENTIN</li>
            <li>WIN_AS_TAXIDERMIST</li>
            <li>QUENTIN_OPEN_LOCK_BLUE</li>
            <li>QUENTIN_OPEN_LOCK_RED</li>
            <li>QUENTIN_OPEN_LOCK_YELLOW</li>
            <li>TAXIDERMIST_HIT_TARGETS_WITHOUT_RELOAD</li>
            <li>QUENTIN_USE_DASH</li>
            <li>CRAFT_INSANITY_SENSOR</li>
          </ul>
        </div>
      </div>
      
      <div class="output" id="questOutput">Quest update results will appear here...</div>
    </div>

    <!-- Additional PlayFab APIs -->
    <div class="section">
      <h2>üîó Additional Stuff</h2>
      <div class="api-grid">
        <div>
          <h3>üë• Add Friend</h3>
          <input id="friendPlayFabId" placeholder="Friend's PlayFab ID" type="text">
          <button onclick="addFriend()">Add Friend</button>
        </div>
        <div>
          <h3>üìã Get Friends List</h3>
          <button onclick="getFriendsList()">Get Friends List</button>
        </div>
        <div>
          <h3>üìõ Update Leaderboard Name</h3>
          <input id="displayName" placeholder="New Display Name" type="text">
          <button onclick="updateDisplayName()">Update Name</button>
        </div>
        <div>
          <h3>üîó Ban Yourself</h3>
          <input id="customId" placeholder="Anything You Want" type="text">
          <button onclick="linkCustomId()">Ban</button>
        </div>
        <div>
          <h3>üèÜ Leaderboard Data</h3>
          <input id="statisticName" placeholder="Statistic Name" type="text">
          <input id="startPosition" placeholder="Start Position" type="number" value="0">
          <input id="maxResults" placeholder="Max Results" type="number" value="100">
          <button onclick="getLeaderboard()">Get Leaderboard</button>
        </div>
        <div>
          <h3>üö© Report Player</h3>
          <select id="reportReason">
            <option value="CHEATING">Cheating</option>
            <option value="VOICE_CHAT_ABUSE">Voice Chat Abuse</option>
            <option value="AFK">AFK</option>
            <option value="TEAMING_WITH_ENEMY">Teaming with Enemy</option>
          </select>
          <input id="targetPlayerId" placeholder="Target PlayFab ID" type="text">
          <button onclick="reportPlayer()">Report Player</button>
        </div>
      </div>
      <div class="output" id="apiOutput">API results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìÑ How to Get Your SessionTicket with Requestly</h2>
      <ol>
        <li>Download the Requestly desktop app from <a href="https://docs.requestly.com/general/sessions/record-api-sessions" target="_blank">here</a>.</li>
        <li>Open Requestly and start recording network traffic.</li>
        <li>Log into your game or app using PlayFab.</li>
        <li>Find the request to <code>/Client/LoginWithSteam</code> or similar.</li>
        <li>Copy the <code>SessionTicket</code> or <code>X-Authorization</code> from the response body.</li>
        <li>Paste it into the field above and click "Set Token".</li>
      </ol>
    </div>
  </div>

  <script>
    const titleId = "bdff1";
    let sessionTicket = null;
    let coinFarmBotRunning = false;
    let coinFarmIntervalId = null;
    let levelEditorRunning = false;
    let levelEditorIntervalId = null;

    function setSessionTicket() {
      sessionTicket = document.getElementById("sessionTicketInput").value.trim();
      const tokenStatus = document.getElementById("tokenStatus");
      
      if (sessionTicket) {
        localStorage.setItem('sessionTicket', sessionTicket);
        tokenStatus.textContent = "‚úÖ Token set successfully!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "green";
        console.log("SessionTicket set:", sessionTicket);
        
       {
        tokenStatus.textContent = "‚ùå Please enter a valid token";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
      }
    }

    function clearSessionTicket() {
      sessionTicket = null;
      localStorage.removeItem('sessionTicket');
      document.getElementById("sessionTicketInput").value = "";
      const tokenStatus = document.getElementById("tokenStatus");
      tokenStatus.textContent = "‚ùå Token cleared";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "red";
    }

    // NEW FUNCTION: Renew Session Ticket
    async function renewSessionTicket() {
      const tokenStatus = document.getElementById("tokenStatus");
      
      if (!sessionTicket) {
        tokenStatus.textContent = "‚ùå No session ticket to renew. Please set a token first.";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
        return;
      }
      
      tokenStatus.textContent = "üîÑ Renewing session ticket...";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "blue";
      
      try {
        const response = await fetch(`https://${titleId}.playfabapi.com/Authentication/GetEntityToken`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify({})
        });
        
        const data = await response.json();
        
        if (data.data && data.data.EntityToken) {
          // Update the session ticket with the new one
          sessionTicket = data.data.EntityToken;
          localStorage.setItem('sessionTicket', sessionTicket);
          document.getElementById("sessionTicketInput").value = sessionTicket;
          
          tokenStatus.textContent = "‚úÖ Session ticket renewed successfully!";
          tokenStatus.style.color = "green";
          
          console.log("SessionTicket renewed:", sessionTicket);
        } else {
          tokenStatus.textContent = `‚ùå Failed to renew session ticket: ${data.errorMessage || "Unknown error"}`;
          tokenStatus.style.color = "red";
        }
      } catch (error) {
        tokenStatus.textContent = `‚ùå Error renewing session ticket: ${error.message}`;
        tokenStatus.style.color = "red";
      }
    }

    async function makeApiCall(endpoint, method, body) {
      if (!sessionTicket) {
        alert("Please set your SessionTicket first.");
        return null;
      }

      try {
        const res = await fetch(`https://${titleId}.playfabapi.com/${endpoint}`, {
          method: method,
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify(body)
        });
        
        return await res.json();
      } catch (error) {
        console.error("API call failed:", error);
        return { error: error.message };
      }
    }

    function formatResponse(result) {
      if (typeof result === "object" && result !== null) {
        return Object.entries(result).map(([key, value]) => `${key}: ${value}`).join("\n");
      }
      return result;
    }

    // NEW FUNCTION: Purchase All Skins and Emotes
    async function purchaseAllSkinsEmotes() {
      const output = document.getElementById("purchaseAllOutput");
      output.textContent = "Starting purchase process...\n";
      
      if (!sessionTicket) {
        output.textContent += "‚ùå Please set your SessionTicket first.\n";
        return;
      }
      
      try {
        // Step 1: Get catalog items
        output.textContent += "üìã Fetching catalog items...\n";
        const catalogData = await makeApiCall("Client/GetCatalogItems", "POST", {
          CatalogVersion: "Ingame"
        });
        
        if (catalogData.error) {
          output.textContent += `‚ùå Failed to get catalog: ${catalogData.error}\n`;
          return;
        }
        
        const catalogItems = catalogData.data.Catalog;
        output.textContent += `‚úÖ Found ${catalogItems.length} items in catalog\n`;
        
        // Step 2: Get user inventory to check what we already own
        output.textContent += "üì¶ Checking current inventory...\n";
        const inventoryData = await makeApiCall("Client/GetUserInventory", "POST", {});
        
        if (inventoryData.error) {
          output.textContent += `‚ùå Failed to get inventory: ${inventoryData.error}\n`;
          return;
        }
        
        const ownedItems = inventoryData.data.Inventory.map(item => item.ItemId);
        output.textContent += `‚úÖ You own ${ownedItems.length} items\n`;
        
        // Step 3: Filter items to purchase (only FE, AC, XP currencies, not owned, and not RM)
        const itemsToPurchase = [];
        
        for (const item of catalogItems) {
          // Skip if already owned
          if (ownedItems.includes(item.ItemId)) {
            output.textContent += `‚è© Skipping ${item.ItemId} (already owned)\n`;
            continue;
          }
          
          // Check if item has virtual currency prices
          if (item.VirtualCurrencyPrices) {
            const currencies = Object.keys(item.VirtualCurrencyPrices);
            
            // Find acceptable currencies (FE, AC, XP) and exclude RM
            const acceptableCurrencies = currencies.filter(currency => 
              ['FE', 'AC', 'XP'].includes(currency) && currency !== 'RM'
            );
            
            if (acceptableCurrencies.length > 0) {
              // Use the first acceptable currency
              const currency = acceptableCurrencies[0];
              const price = item.VirtualCurrencyPrices[currency];
              
              itemsToPurchase.push({
                ItemId: item.ItemId,
                Price: price,
                VirtualCurrency: currency
              });
              
              output.textContent += `‚ûï Will purchase ${item.ItemId} for ${price} ${currency}\n`;
            } else {
              output.textContent += `‚è© Skipping ${item.ItemId} (no acceptable currency)\n`;
            }
          } else {
            output.textContent += `‚è© Skipping ${item.ItemId} (no virtual currency price)\n`;
          }
        }
        
        output.textContent += `\nüõí Attempting to purchase ${itemsToPurchase.length} items...\n\n`;
        
        // Step 4: Purchase items one by one
        let successfulPurchases = 0;
        let failedPurchases = 0;
        
        for (const item of itemsToPurchase) {
          try {
            output.textContent += `üõçÔ∏è Purchasing ${item.ItemId} for ${item.Price} ${item.VirtualCurrency}... `;
            
            const purchaseData = await makeApiCall("Client/PurchaseItem", "POST", {
              ItemId: item.ItemId,
              Price: item.Price,
              VirtualCurrency: item.VirtualCurrency
            });
            
            if (purchaseData.error) {
              output.textContent += `‚ùå Failed: ${purchaseData.errorMessage || purchaseData.error}\n`;
              failedPurchases++;
            } else {
              output.textContent += `‚úÖ Success!\n`;
              successfulPurchases++;
            }
          } catch (err) {
            output.textContent += `‚ùå Error: ${err.message}\n`;
            failedPurchases++;
          }
          
          // Add a small delay between purchases to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        output.textContent += `\nüéâ Purchase process completed!\n`;
        output.textContent += `‚úÖ Successful: ${successfulPurchases}\n`;
        output.textContent += `‚ùå Failed: ${failedPurchases}\n`;
        
      } catch (error) {
        output.textContent += `‚ùå Unexpected error: ${error.message}\n`;
      }
      
      // Scroll to bottom to see latest logs
      output.scrollTop = output.scrollHeight;
    }

    // EXISTING FUNCTIONS
    async function addFriend() {
      const friendPlayFabId = document.getElementById("friendPlayFabId").value.trim();
      
      if (!friendPlayFabId) {
        document.getElementById("apiOutput").textContent = "Please enter a friend's PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/AddFriend", "POST", {
        FriendPlayFabId: friendPlayFabId
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getFriendsList() {
      const data = await makeApiCall("Client/GetFriendsList", "POST", {
        IncludeSteamFriends: false,
        IncludeFacebookFriends: false
      });

      const output = document.getElementById("apiOutput");
      
      if (data.data && data.data.Friends) {
        let friendsList = "Friends List:\n";
        data.data.Friends.forEach(friend => {
          friendsList += `- ${friend.Username} (${friend.PlayFabId})\n`;
        });
        output.textContent = friendsList;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data);
      }
    }

    async function updateDisplayName() {
      const displayName = document.getElementById("displayName").value.trim();
      
      if (!displayName) {
        document.getElementById("apiOutput").textContent = "Please enter a display name.";
        return;
      }

      const data = await makeApiCall("Client/UpdateUserTitleDisplayName", "POST", {
        DisplayName: displayName
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function linkCustomId() {
      const customId = document.getElementById("customId").value.trim();
      
      if (!customId) {
        document.getElementById("apiOutput").textContent = "Please enter a custom ID.";
        return;
      }

      const data = await makeApiCall("Client/LinkCustomID", "POST", {
        CustomId: customId,
        ForceLink: false
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getLeaderboard() {
      const statisticName = document.getElementById("statisticName").value.trim();
      const startPosition = parseInt(document.getElementById("startPosition").value) || 0;
      const maxResults = parseInt(document.getElementById("maxResults").value) || 10;
      
      if (!statisticName) {
        document.getElementById("apiOutput").textContent = "Please enter a statistic name.";
        return;
      }

      const data = await makeApiCall("Client/GetLeaderboard", "POST", {
        StatisticName: statisticName,
        StartPosition: startPosition,
        MaxResultsCount: maxResults
      });

      const output = document.getElementById("apiOutput");
      
      if (data.data && data.data.Leaderboard) {
        let leaderboardText = `Leaderboard for ${statisticName}:\n\n`;
        data.data.Leaderboard.forEach((entry, index) => {
          leaderboardText += `${startPosition + index + 1}. ${entry.DisplayName}: ${entry.StatValue}\n`;
        });
        output.textContent = leaderboardText;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data);
      }
    }

    async function reportPlayer() {
      const reportReason = document.getElementById("reportReason").value;
      const targetPlayerId = document.getElementById("targetPlayerId").value.trim();
      
      if (!targetPlayerId) {
        document.getElementById("apiOutput").textContent = "Please enter a target PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "reportPlayer",
        FunctionParameter: {
          reportReason: reportReason,
          targetPlayerId: targetPlayerId
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function buySkinEmote() {
      const ItemId = document.getElementById("itemId").value.trim();
      const Price = parseInt(document.getElementById("price").value);
      const VirtualCurrency = document.getElementById("currency").value.trim();
      
      if (!ItemId || isNaN(Price) || !VirtualCurrency) {
        document.getElementById("purchaseOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/PurchaseItem", "POST", {
        ItemId,
        Price,
        VirtualCurrency
      });

      const output = document.getElementById("purchaseOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

 async function grantCoupons() {
  const output = document.getElementById("couponOutput");
  output.textContent = "Starting coupon grant process...";
  
  try {
    // Start purchase
    output.textContent += "\nStarting purchase...";
    const startData = await makeApiCall("Client/StartPurchase", "POST", {
      StoreId: "steam_Shop_Currency",
      Items: [{
        ItemId: "Currency_Bundle_PileOfCoupons",
        Quantity: 1
      }]
    });

    if (startData.error) {
      output.textContent += `\nError in StartPurchase: ${startData.error}`;
      return;
    }

    const orderId = startData.data?.OrderId;
    if (!orderId) {
      output.textContent += "\nStartPurchase failed. No OrderId returned.";
      return;
    }

    output.textContent += `\nOrder ID: ${orderId}`;
    
    // Pay for purchase
    output.textContent += "\nPaying for purchase...";
    const payData = await makeApiCall("Client/PayForPurchase", "POST", {
      OrderId: orderId,
      Currency: "RM",
      ProviderName: "Steam"
    });

    // Always try to confirm purchase regardless of payment result
    output.textContent += "\nConfirming purchase...";
    
    // Confirm purchase
    const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
      OrderId: orderId
    });

    if (confirmData.error) {
      output.textContent += `\nError in ConfirmPurchase: ${confirmData.error}`;
    } else {
      output.textContent += "\nCoupon process completed:\n" + 
        formatResponse(confirmData.data);
    }
      
  } catch (error) {
    output.textContent += `\nUnexpected error: ${error.message}`;
  }
}

    
      

    async function viewStatistics() {
      const data = await makeApiCall("Client/GetPlayerStatistics", "POST", {});
      const output = document.getElementById("statsOutput");
      
      if (data.data?.Statistics) {
        const stats = data.data.Statistics.map(stat => 
          `${stat.StatisticName}: ${stat.Value}`
        ).join("\n");
        output.textContent = stats || "No statistics found.";
      } else {
        output.textContent = "Error retrieving statistics: " + 
          (data.error || "Unknown error");
      }
    }

    async function getPlayFabId() {
      const steamUsername = document.getElementById("steamUsername").value.trim();
      if (!steamUsername) {
        alert("Please enter a Steam username.");
        return;
      }

      const data = await makeApiCall("Client/GetPlayFabIDsFromSteamNames", "POST", {
        SteamNames: [steamUsername]
      });

      const output = document.getElementById("playerIdOutput");
      if (data.data?.Data?.[0]) {
        const match = data.data.Data[0];
        output.textContent = `PlayFabId for "${steamUsername}": ${match.PlayFabId}`;
      } else {
        output.textContent = "No matching PlayFab ID found.";
      }
    }

    async function AddCoin() {
      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "usefulDeed",
        FunctionParameter: {},
        GeneratePlayStreamEvent: true
      });

      const output = document.getElementById("usefulDeedOutput");
      if (data.data?.FunctionResult) {
        const result = data.data.FunctionResult;
        output.textContent = `‚úÖ usefulDeed Result:\n${formatResponse(result)}`;
      } else {
        output.textContent = "Error: " + (data.error || "Unknown error");
      }
    }

    async function submitLevelProgression() {
      const classId = document.getElementById("classIdInput").value.trim();
      const receivedXP = parseInt(document.getElementById("receivedXPInput").value);
      const XP = parseInt(document.getElementById("xpInput").value);
      const XpToNextLevel = parseInt(document.getElementById("xpToNextLevelInput").value);
      const level = parseInt(document.getElementById("levelInput").value);
      const availablePerkSlotsCount = Math.min(parseInt(document.getElementById("perkSlotsInput").value), 3);
      const playerLevel = parseInt(document.getElementById("playerLevelInput").value);

      if (!classId || isNaN(receivedXP) || isNaN(XP) || isNaN(XpToNextLevel) || 
          isNaN(level) || isNaN(availablePerkSlotsCount) || isNaN(playerLevel)) {
        return { error: "Please fill in all fields correctly." };
      }

      const currentLevelProgression = {
        playerLevel,
        classLevel: [{
          classId,
          XP,
          XpToNextLevel,
          level,
          availablePerkSlotsCount
        }]
      };

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "setLevelProgressionForClass",
        FunctionParameter: {
          classId,
          receivedXP,
          currentLevelProgression: JSON.stringify(currentLevelProgression)
        },
        GeneratePlayStreamEvent: true
      });

      return data;
    }

    async function getPlayFabInfo() {
      const playfabId = document.getElementById("playfabId").value.trim();
      const output = document.getElementById("playfabInfoOutput");
      
      if (!playfabId) {
        output.textContent = "Please enter a PlayFab ID.";
        return;
      }

      output.textContent = "Fetching data...";

      // Get combined info
      const combinedData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
        PlayFabId: playfabId,
        InfoRequestParameters: {
          GetUserAccountInfo: true,
          GetPlayerStatistics: true,
          GetUserInventory: true
        }
      });

      // Get profile info
      const profileData = await makeApiCall("Client/GetPlayerProfile", "POST", {
        PlayFabId: playfabId,
        ProfileConstraints: {
          ShowLastLogin: true,
          ShowBannedUntil: true
        }
      });

      let resultText = "";
      
      if (combinedData.data) {
        const info = combinedData.data.InfoResultPayload;
        resultText += "=== ACCOUNT INFO ===\n";
        resultText += `Username: ${info.AccountInfo.TitleInfo?.DisplayName || "N/A"}\n`;
        resultText += `Created: ${info.AccountInfo.Created || "N/A"}\n`;
        resultText += "\n=== STATISTICS ===\n";
        
        if (info.PlayerStatistics) {
          info.PlayerStatistics.forEach(stat => {
            resultText += `${stat.StatisticName}: ${stat.Value}\n`;
          });
        }
      }

      if (profileData.data) {
        const profile = profileData.data.PlayerProfile;
        resultText += "\n=== PROFILE INFO ===\n";
        resultText += `Last Login: ${profile.LastLogin || "N/A"}\n`;
        resultText += `Banned Until: ${profile.BannedUntil || "Not banned"}\n`;
      }

      if (combinedData.error || profileData.error) {
        resultText += "\n=== ERRORS ===\n";
        if (combinedData.error) resultText += `Combined Info Error: ${combinedData.error}\n`;
        if (profileData.error) resultText += `Profile Error: ${profileData.error}\n`;
      }

      output.textContent = resultText || "No data received.";
    }

    async function updateQuestProgress() {
      const questTextFieldId = document.getElementById("questTextFieldId").value.trim();
      const progressValue = parseInt(document.getElementById("questProgressValue").value);
      
      if (!questTextFieldId || isNaN(progressValue)) {
        document.getElementById("questOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "updateActiveQuests",
        FunctionParameter: {
          updatedValues: `{"${questTextFieldId}":${progressValue}}`
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const output = document.getElementById("questOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    function toggleCoinFarmBot() {
      if (coinFarmBotRunning) {
        clearInterval(coinFarmIntervalId);
        coinFarmBotRunning = false;
        document.getElementById("botStatus").className = "status-indicator status-inactive";
        document.getElementById("botToggleButton").textContent = "Start Coin Farm Bot";
        document.getElementById("cloudOutput").textContent += "\nBot stopped manually.";
        return;
      }

      const delayMinutes = parseInt(document.getElementById("delaySelect").value);
      const delayMs = delayMinutes * 60 * 1000;

      coinFarmBotRunning = true;
      document.getElementById("botStatus").className = "status-indicator status-active";
      document.getElementById("botToggleButton").textContent = "Stop Coin Farm Bot";

      document.getElementById("cloudOutput").textContent = 
        `Starting Coin Farm Bot with ${delayMinutes} minute interval...\n`;

      async function runCoinFarmCycle() {
        const roomType = document.getElementById("roomType").value;
        const playerIds = [
          document.getElementById("playerId1").value.trim(),
          document.getElementById("playerId2").value.trim(),
          document.getElementById("playerId3").value.trim(),
          document.getElementById("playerId4").value.trim(),
          document.getElementById("playerId5").value.trim(),
          document.getElementById("playerId6").value.trim()
        ].filter(id => id);

        let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;
        output += `Room Type: ${roomType}\nPlayers: ${playerIds.join(", ") || "None"}\n`;

        let matchId = null;

        // startNewMatch
        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "startNewMatch",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå startNewMatch: Error - ${data.error}\n`;
          } else {
            const result = data.data?.FunctionResult;
            output += `‚úÖ startNewMatch: ${formatResponse(result)}\n`;
            if (result && result.CurrentMatchId) {
              matchId = result.CurrentMatchId;
              output += `New MatchId: ${matchId}\n`;
            }
          }
        } catch (err) {
          output += `‚ùå startNewMatch: Exception - ${err.message}\n`;
        }

        // decideSpecialRole
        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "decideSpecialRole",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå decideSpecialRole: Error - ${data.error}\n`;
          } else {
            const result = data.data?.FunctionResult;
            output += `‚úÖ decideSpecialRole: ${formatResponse(result)}\n`;
          }
        } catch (err) {
          output += `‚ùå decideSpecialRole: Exception - ${err.message}\n`;
        }

        // xpConsumed if matchId available
        if (matchId) {
          try {
            const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
              CustomTags: null,
              FunctionName: "xpConsumed",
              FunctionParameter: {
                token: matchId
              },
              GeneratePlayStreamEvent: true,
              RevisionSelection: null,
              SpecificRevision: null,
              AuthenticationContext: null
            });

            if (data.error) {
              output += `‚ùå xpConsumed: Error - ${data.error}\n`;
            } else {
              const result = data.data?.FunctionResult;
              output += `‚úÖ xpConsumed: ${formatResponse(result)}\n`;
            }
          } catch (err) {
            output += `‚ùå xpConsumed: Exception - ${err.message}\n`;
          }
        } else {
          output += `‚è© xpConsumed: Skipped - No MatchId available\n`;
        }

        // finishMatch
        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "finishMatch",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå finishMatch: Error - ${data.error}\n`;
          } else {
            const result = data.data?.FunctionResult;
            output += `‚úÖ finishMatch: ${formatResponse(result)}\n`;
          }
        } catch (err) {
          output += `‚ùå finishMatch: Exception - ${err.message}\n`;
        }

        output += `Waiting ${delayMinutes} minutes for next cycle...\n`;
        const cloudOutput = document.getElementById("cloudOutput");
        cloudOutput.textContent += output;
        cloudOutput.scrollTop = cloudOutput.scrollHeight;
      }

      // Run first cycle immediately
      runCoinFarmCycle();
      
      // Set up interval for subsequent cycles
      coinFarmIntervalId = setInterval(runCoinFarmCycle, delayMs);
    }

    function toggleLevelEditor() {
      if (levelEditorRunning) {
        clearInterval(levelEditorIntervalId);
        levelEditorRunning = false;
        document.getElementById("levelEditorStatus").className = "status-indicator status-inactive";
        document.getElementById("levelEditorToggleButton").textContent = "Start Level Editor";
        document.getElementById("levelProgressionOutput").textContent += "\nLevel editor stopped manually.";
        return;
      }

      levelEditorRunning = true;
      document.getElementById("levelEditorStatus").className = "status-indicator status-active";
      document.getElementById("levelEditorToggleButton").textContent = "Stop Level Editor";

      document.getElementById("levelProgressionOutput").textContent = 
        `Starting Level Editor...\n`;

      async function runLevelEditorCycle() {
        let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;

        try {
          const data = await submitLevelProgression();

          if (data.error) {
            output += `‚ùå setLevelProgressionForClass: Error - ${data.error}\n`;
          } else {
            const result = data.data?.FunctionResult;
            output += `‚úÖ setLevelProgressionForClass: ${formatResponse(result)}\n`;
          }
        } catch (err) {
          output += `‚ùå setLevelProgressionForClass: Exception - ${err.message}\n`;
        }

        const levelOutput = document.getElementById("levelProgressionOutput");
        levelOutput.textContent += output;
        levelOutput.scrollTop = levelOutput.scrollHeight;
      }

      // Run continuously with no delay (but add minimal timeout to avoid blocking)
      levelEditorIntervalId = setInterval(runLevelEditorCycle, 100); // 100ms minimal delay to prevent overload
    }

    // Initialize page
    document.addEventListener("DOMContentLoaded", function() {
      console.log("Secret Neighbor Exploits page loaded");
      const savedTicket = localStorage.getItem('sessionTicket');
      if (savedTicket) {
        sessionTicket = savedTicket;
        document.getElementById("sessionTicketInput").value = savedTicket;
        const tokenStatus = document.getElementById("tokenStatus");
        tokenStatus.textContent = "‚úÖ Token loaded from storage!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "green";
      }
    });
  </script>
</body>
</html>
